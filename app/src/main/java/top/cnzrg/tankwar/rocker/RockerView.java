package top.cnzrg.tankwar.rocker;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.PointF;import android.graphics.Rect;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewTreeObserver;import android.view.ViewTreeObserver.OnPreDrawListener;import top.cnzrg.tankwar.R;public class RockerView        extends View {    private Bitmap mBmpRockerBg;    private Bitmap mBmpRockerBtn;    private PointF mCenterPoint;    private float mRockerBg_R;    private float mRockerBg_X;    private float mRockerBg_Y;    private float mRockerBtn_R;    private float mRockerBtn_X;    private float mRockerBtn_Y;    RockerChangeListener mRockerChangeListener = null;    public RockerView(Context paramContext, AttributeSet paramAttributeSet) {        super(paramContext, paramAttributeSet);        this.mBmpRockerBg = BitmapFactory.decodeResource(paramContext.getResources(), R.drawable.yaogan_bg);        this.mBmpRockerBtn = BitmapFactory.decodeResource(paramContext.getResources(), R.drawable.yangan_center);        /*getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {            public boolean onPreDraw() {                RockerView.this.getViewTreeObserver().removeOnPreDrawListener(this);                StringBuilder localStringBuilder = new StringBuilder();                localStringBuilder.append(RockerView.this.getWidth());                localStringBuilder.append("/");                localStringBuilder.append(RockerView.this.getHeight());                Log.e("RockerView", localStringBuilder.toString());                RockerView.access$002(RockerView.this, new PointF(RockerView.this.getWidth() / 2, RockerView.this.getHeight() / 2));                RockerView.access$102(RockerView.this, RockerView.this.mCenterPoint.x);                RockerView.access$202(RockerView.this, RockerView.this.mCenterPoint.y);                RockerView.access$302(RockerView.this, RockerView.this.mCenterPoint.x);                RockerView.access$402(RockerView.this, RockerView.this.mCenterPoint.y);                float f = RockerView.this.mBmpRockerBg.getWidth() / (RockerView.this.mBmpRockerBg.getWidth() + RockerView.this.mBmpRockerBtn.getWidth());                RockerView.access$702(RockerView.this, f * RockerView.this.getWidth() / 2.0F);                RockerView.access$802(RockerView.this, (1.0F - f) * RockerView.this.getWidth() / 2.0F);                return true;            }        });*/        getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {            // 调用该方法时可以获取view实际的宽getWidth()和高getHeight()            @Override            public boolean onPreDraw() {                getViewTreeObserver().removeOnPreDrawListener(this);                Log.e("RockerView", getWidth() + "/" + getHeight());                mCenterPoint = new PointF(getWidth() / 2, getHeight() / 2);                mRockerBg_X = mCenterPoint.x;                mRockerBg_Y = mCenterPoint.y;                mRockerBtn_X = mCenterPoint.x;                mRockerBtn_Y = mCenterPoint.y;                float tmp_f = mBmpRockerBg.getWidth() / (float) (mBmpRockerBg.getWidth() + mBmpRockerBtn.getWidth());                mRockerBg_R = tmp_f * getWidth() / 2;                mRockerBtn_R = (1.0f - tmp_f) * getWidth() / 2;                return true;            }        });        new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    //系统调用onDraw方法刷新画面                    RockerView.this.postInvalidate();                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        }).start();    }    /***     * 得到两点之间的弧度     */    public double getRad(float px1, float py1, float px2, float py2) {        //得到两点X的距离        float x = px2 - px1;        //得到两点Y的距离        float y = py1 - py2;        //算出斜边长        float xie = (float) Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));        //得到这个角度的余弦值（通过三角函数中的定理 ：邻边/斜边=角度余弦值）        float cosAngle = x / xie;        //通过反余弦定理获取到其角度的弧度        float rad = (float) Math.acos(cosAngle);        //注意：当触屏的位置Y坐标<摇杆的Y坐标我们要取反值-0~-180        if (py2 < py1) {            rad = -rad;        }        return rad;    }    public void getXY(float paramFloat1, float paramFloat2, float paramFloat3, double paramDouble) {        this.mRockerBtn_X = (paramFloat1 + (float) (paramFloat3 * Math.cos(paramDouble)));        this.mRockerBtn_Y = (paramFloat2 + (float) (paramFloat3 * Math.sin(paramDouble)));    }    @Override    protected void onDraw(Canvas paramCanvas) {        super.onDraw(paramCanvas);        paramCanvas.drawBitmap(mBmpRockerBg, null,                new Rect((int) (mRockerBg_X - mRockerBg_R),                        (int) (mRockerBg_Y - mRockerBg_R),                        (int) (mRockerBg_X + mRockerBg_R),                        (int) (mRockerBg_Y + mRockerBg_R)),                null);        paramCanvas.drawBitmap(mBmpRockerBtn, null,                new Rect((int) (mRockerBtn_X - mRockerBtn_R),                        (int) (mRockerBtn_Y - mRockerBtn_R),                        (int) (mRockerBtn_X + mRockerBtn_R),                        (int) (mRockerBtn_Y + mRockerBtn_R)),                null);    }    @Override    public boolean onTouchEvent(MotionEvent event) {        /*if ((paramMotionEvent.getAction() != 0) && (paramMotionEvent.getAction() != 2)) {            if (paramMotionEvent.getAction() == 1) {                this.mRockerBtn_X = this.mCenterPoint.x;                this.mRockerBtn_Y = this.mCenterPoint.y;                if (this.mRockerChangeListener != null) {                    this.mRockerChangeListener.report(0.0F, 0.0F);                }            }        } else {            if (Math.sqrt(Math.pow(this.mRockerBg_X - (int) paramMotionEvent.getX(), 2.0D) + Math.pow(this.mRockerBg_Y - (int) paramMotionEvent.getY(), 2.0D)) >= this.mRockerBg_R) {                double d = getRad(this.mRockerBg_X, this.mRockerBg_Y, paramMotionEvent.getX(), paramMotionEvent.getY());                getXY(this.mRockerBg_X, this.mRockerBg_Y, this.mRockerBg_R, d);            } else {                this.mRockerBtn_X = ((int) paramMotionEvent.getX());                this.mRockerBtn_Y = ((int) paramMotionEvent.getY());            }            if (this.mRockerChangeListener != null) {                this.mRockerChangeListener.report(this.mRockerBtn_X - this.mCenterPoint.x, this.mRockerBtn_Y - this.mCenterPoint.y);            }        }        return true;*/        // TODO Auto-generated method stub        if (event.getAction() == MotionEvent.ACTION_DOWN || event.getAction() == MotionEvent.ACTION_MOVE) {            // 当触屏区域不在活动范围内            if (Math.sqrt(Math.pow((mRockerBg_X - (int) event.getX()), 2) + Math.pow((mRockerBg_Y - (int) event.getY()), 2)) >= mRockerBg_R) {                //得到摇杆与触屏点所形成的角度                double tempRad = getRad(mRockerBg_X, mRockerBg_Y, event.getX(), event.getY());                //保证内部小圆运动的长度限制                getXY(mRockerBg_X, mRockerBg_Y, mRockerBg_R, tempRad);            } else {//如果小球中心点小于活动区域则随着用户触屏点移动即可                mRockerBtn_X = (int) event.getX();                mRockerBtn_Y = (int) event.getY();            }            if (mRockerChangeListener != null) {                mRockerChangeListener.report(mRockerBtn_X - mCenterPoint.x, mRockerBtn_Y - mCenterPoint.y);            }        } else if (event.getAction() == MotionEvent.ACTION_UP) {            //当释放按键时摇杆要恢复摇杆的位置为初始位置            mRockerBtn_X = mCenterPoint.x;            mRockerBtn_Y = mCenterPoint.y;            if (mRockerChangeListener != null) {                mRockerChangeListener.report(0, 0);            }        }        return true;    }    public void setRockerChangeListener(RockerChangeListener paramRockerChangeListener) {        this.mRockerChangeListener = paramRockerChangeListener;    }    public static abstract interface RockerChangeListener {        public abstract void report(float paramFloat1, float paramFloat2);    }}